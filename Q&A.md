[TOC]

## 1.对象的创建过程  

（开辟空间、构造方法、引用指向对象的地址指针)

 对象在内存中存储布局  markword （对象头 8个字节）、class pointer(类型指针 4个字节) 、实例数据 、对齐 （不能被8整除，补位）

分析对象在内存的布 org.openjdk.jol jol-core 0.9

对象定位  句柄方式 直接方式

## 2.java内存模型

- 可见性  线程之间的可见性，一个线程修改的状态对另一个线程是可见的

- 原子性  原子是世界上最小的单位，具有不可分割性。

  java的concurrent包下提供了一些原子类：AtomicInteger、 AtomicLong、 AtomicReference等

- 有序性

  

## 3.volatile

volatile 具有可见性和有序性，一旦一个共享变量被volatile修饰后，不同线程对这个变量进行的操作，这个值对其他变量是可见的。使用volatile,会强制将修改写入主存。cpu的L1和L2缓冲无效。其他线程只能去主存读取。

volatile能保证操作的有序性，防止指令重排，但是不能保证原子性。

加入volatile关键字的区别，会多一个lock前缀指令，设置y一个内存屏障

- 确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的排到内存屏障的后面；即在执行内存屏障这条指令时，前面的指令全部执行完了。
- 强制将对缓存的修改操作立即写入主存
- 如果是写操作，会导致其他CPU中duiy对应的操作无效。

## 4.为什么DCL要使用volatile ？ 

DCL 指的是单例中的Dobule Check Lock 双重锁。 在CPU执行指令的过程中，会小概率的发生指令重排。对象的创建过程是

1. new 开辟空间

2. init 对象属性赋值

3. 引用指向对象的地址指针

   如果2和3发生了指令重排，那么拿到的对象可能是属性为空的对象。

## 5.synchronized

synchronized是一个同步关键字,在某些多线程场景下，如果不进行同步会导致数据不安全：

- 数据共享
- 多线程同时访问并改变该数据

使用场景：

- synchronized修饰普通同步方法：锁对象当前实例对象
- synchronized修饰静态同步方法：锁对象是当前的类class对象；
- synchronized修饰同步代码块：锁对象是｛｝里面配置的对象，这个对象可以是某个对象，也可以是某个类。

注意：

- 使用synchronized修饰非静态方法或者使用synchronized修饰代码块时，为实例对象。同一个类的不同对象拥有自己的锁，因此不会阻塞。
- 使用synchronized修饰类和对象时，由于类对象和实例对象分别拥有自己的监视器锁，因此不会相互阻塞。
- 使用synchronized修饰实例对象时，如果一个线程正在访问实例对象的一个synchronized方法时，其他线程不仅不能访问该synchronized方法，该对象的其他synchronized方法也不能fa访问，因为一个对象只有一个监视器对象，但是其它线程可以访问该对象的非synchronized方法。
- 线程A访问实例对象的非static synchronized方法时，线程B也可以同时访问实例对象的static synchronized方法，因为前者获取的是实例对象的监视器锁，后者后去的是类对象的监视器锁。

## 6.jvm参数的

- java -XX:+PrintCommandLineFlags -version 

- -XX:InitialHeapSize  初始化堆大小

- -XX:MaxHeapSize 最大堆大小
- -XX:+PrintCommandLineFlags
- -XX:+UseCompressedClasssPointers  压缩类型指针
- -XX:+UseCompressedOops  压缩对象指针
- -XX:-UseLargePagesIndividualAllocation 
- -XX:+UsePaalleGC



## 7.锁升级

 ![](.\img\20180322153259479.jpg)

![](.\img\20180322153316377.jpg)

- 无锁


- 偏向锁  大多数时候不存在锁竞争，常常是一个线程多次获得同一个锁，如果每次都要竞争锁会增大很多没必要付出代价，为了降低获取锁的代价，引入偏向锁。

  当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向锁的threadId，因为偏向锁不会主动释放锁。因此以后线程1再次获取锁的时候，需要比较当前线程threadId和java对象头的threadId是否一致，如果一致，无需使用CAS来加锁、解锁。如果不一致（线程1锁，线程2来加锁），需要查看线程1是否存活，如果没有存活，那么锁对象重置为无锁状态，然后将线程2设为偏向锁，如果存活，线程1栈帧还是持有这个对象。那么将持有锁的线程暂停，撤销偏向锁，升级为轻量级锁。如果线程1不再使用该锁，那么锁对象为无锁状态，线程2设为偏向锁

- 轻量级锁（CAS）  考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长。因为阻塞线程需要CPU从用户态转到内核态，代价较大。如果刚刚阻塞不久这个锁就被释放了，那么代价就有点得不偿失。因此就不阻塞线程，采用自旋锁。

  线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间（DisplacedMarkWord），然后使用CAS把对象头中的内容替换为线程1存储的锁记录的地址。

  如果线程1复制对象头的同时，线程2也准备获取锁，复制了对象头到线程2的锁记录中，但是线程2在CAS的时候，发现线程1已经把对象头换了，线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。
  
  如果自旋的时间太长，自旋也要消耗CPU。因此自旋的次数是有限制的，自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自选等待。如果线程3过来竞争这个锁，那么这时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。

## 8.锁粗化

同步块的作用范围应该尽可能小，仅在共享数据的实际作用域中进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，缩短阻塞时间，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。

但是加锁解锁也需要消耗资源，如果存在一系列的连续加锁解锁操作，可能会导致不必要的性能损耗。锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。

## 9.锁消除

java虚拟机在JIT编译时，通过对运行上下文的扫描，经过逃逸分析，去除不可能存在共享资源竞争的锁，通过这种方式消除没必要的锁，可以节省毫无意义的请求锁时间。

## 10.对象分配

![](F:\个人\学习\learn-note\img\20201102154529.png)

首先往栈上分配，分配不了，如果特别大直接分配老年代，fullGC 时可能会回收。不大不小，往TLAB(thread local alloctation buffer)分，分不下，往EDEN,经历过一次垃圾回收，存活下来放s1,多次回收，年龄够了，往老年代分

## 11.垃圾回收

### 11.1 如何定位垃圾

- 引用计数

- 根可达算法

  线程栈变量    静态变量   常量池   class类

### 11.2常见的垃圾回收算法

- 标记清除（mark-sweep）-位置不连续 产生碎片
- 拷贝算法(copying)-有碎片，浪费空间
- 标记压缩(mark-compact)-没有碎片，效率偏低

### 11.3内存分代模型

- 新生代+老年代+永久代（1.7）+元数据（1.8）
- 永久代/元数据区  存放class文件
- 永久代必须指定大小限制，元数据区可以设置，也可以不设置
- 字符串常量 1.7存放永久代 1.8 堆

### 11.4 新生代

- Eden + 2个suvivor区 8：1：1
- YGC回收之后，大多数的对象会被回收，活着的进入s0
- 再次YGYGC,活着的对象eden + s0 --> s1
- 再次YGC, eden + s1 --> s0
- 年龄足够 --> 老年代 （15  cms 6）
- s区装不下 --> 老年代

### 11.5 老年代

- full GC --> FGC

### 11.6 GC Tuning

- 尽量减少FGC
- MinorGC = YGC
- MajorGC = FGC

### 11.7 垃圾回收器

-  Serial   年轻代  单线程  stop the world 串行回收 

- parNew  年轻代 配合CMS 并行回收

- Parallel  Scavenge    年轻代 并行回收

- Epsilon

- CMS  ConcurrenMarkSweep 老年代 并发的  垃圾回收和应用程序同时运行，降低STW的时间（200ms）

  1.初始标记  找到Root 线程栈变量 常量池  静态变量  class文件 这是一个stop the world 过程，但是y因为Root比较少，停顿时间短

  2.并发标记  工作线程和垃圾回收线程一起运行，根据第一步找的根节点往下找可回收对象

  3.重新标记  找出在程序运行过程中，错判的对象

  4.并发清理  将三次标记的对象回收

- Serial Old

- Parallel Old

- G1(10ms)

- ZGC(1ms)

- Shenandoah

![](F:\learn-note\img\20201101223811.png)

### 11.8 jvm参数

-XX :+PrintFlagsFinal 最终参数值

-XX:+PrintCommandLineFlags 参数设置值

-XX :+PrintFlagsInitial 默认参数值





