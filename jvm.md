# 什么是JVM

​	Java virtual Machine 的缩写。是一个虚构出来的计算机。通过在计算机上仿真模拟各种计算功能实现。为java提供runtime环境，java程序只需要提供字节码，jvm就可以将字节码翻译成各平台上机器指令执行。

# JVM原理

​	类加载器 -> 执行引擎 ->  运行时数据区（栈、堆、本地方法栈、程序计数器、元数据区）

# 对象生命周期

​	对象最开始存储在eden区，与surivor1、surivor在新生代的比例为8：1：1。最开始使用的是eden 和surivor1,当eden内存满了之后，存活的对象转surivor2，年龄+1。在下一个eden满的时候，存活的对象转surivor2，年龄再+1。如果新对象内存过大，超过内存的50%，会直接转老年代，称为担保。

# 对象的创建过程  

当虚拟机遇到一条字节码new指令后，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化，然后分配内存。

分析对象在内存的布局  org.openjdk.jol jol-core 0.9

![](F:/learn-note/img/20201102154529.png)

首先往栈上分配，分配不了，如果特别大直接分配老年代，fullGC 时可能会回收。不大不小，往TLAB(thread local alloctation buffer)分，分不下，往EDEN,经历过一次垃圾回收，存活下来放s1,多次回收，年龄够了，往老年代分

# 对象的内存布局

- 对象头  用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID,偏向时间戳。
- 实例数据
- 对齐填充

# 虚拟机参数

java -XX:+PrintCommandLineFlags -version 
       -XX:InitialHeapSize  初始化堆大小

-XX:MaxHeapSize 最大堆大小
	-XX:+PrintCommandLineFlags
	-XX:+UseCompressedClasssPointers  压缩类型指针
	-XX:+UseCompressedOops  压缩对象指针
	-XX:-UseLargePagesIndividualAllocation 
	-XX:+UsePaalleGC

# 内存区域

## 程序计数器

当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。各个线程之间计数器互不影响，所以是线程私有

## Java虚拟机栈

虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存储局部变量表，操作数栈，动态连接。方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。

## 本地方法栈

本地方法栈和虚拟机栈作用类似，为虚拟机使用到的本地方法服务（Native）

## 堆

所有线程共享。存储对象实例  -Xmx -Xms 设定内存大小。

首先往栈上分配，分配不了，如果特别大直接分配老年代，fullGC 时可能会回收。不大不小，往TLAB(thread local alloctation buffer)分，分不下，往EDEN,经历过一次垃圾回收，存活下来放s1,多次回收，年龄够了，往老年代放

## 方法区

各个线程共享的内存区域，用于存储已经被虚拟机加载的类型信息，常量，静态变量，计时编译器编译后的代码缓存等数据。JDK8以前称为“永久代”， JDK9后称为元空间。

运行时常量池：存放编译期生成的各种字面量与符号引用。

## 直接内存

# OutOfMemoryError

## Java堆溢出

### 内存泄露 

泄露对象到GC Roots的引用链，找到泄露对象是通过怎样的引用路径、与那些GC Roots相关联，才导致垃圾收集器无法回收它们。根据泄露对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确的定位到这些对象的创建位置，进而找到产生内存泄露的代码和具体位置

### 内存溢出

检查Java虚拟机的堆参数设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有使劲过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。

## 虚拟机栈和本地方法栈溢出

如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError

如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请都足够的内存时，将抛出OutOfMemoryError

-Xss参数设置栈内存容量

HotSpot虚拟机不支持内存扩展，所以无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候，都抛出StackOverflowError.

## 本机直接内存溢出

直接内存的容量大小可以通过-XX:MaxDirectMemorySize参数来指定，如果不去指定，默认与Java堆最大值一致。

# 引用分类

## 强引用 

通过new Object() 创建的对象。无论在任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。

## 软引用

通过SoftReference类来实现软引用。 在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。如果这次回收hai还没有足够的内存，才会抛出内存溢出异常。

## 弱引用

通过WeakReference类来实现弱引用。 强度比软引用更弱，被弱引用关联的对象只能生存在xia'y下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱y引用关联的对象。

## 虚引用

通过PhantomReference来实现虚引用。无法通过虚引用来取得一个对象实例，为一个对象设置虚引用的wei'y唯一目的，就是为了能在这个对象被收集器h回收时收到yi'g一个系统通知。

#  如何定位垃圾

- 引用计数

- 根可达算法

  GC Roots对象： 

  1. 在虚拟机栈中引用的对象。线程被调用的方法堆栈中使用到的参数，局部变量，临时变量。
  2. 在方法区中类静态属性引用的对象。Java类的引用类型静态变量
  3. 本地方法栈中常量引用的对象。 字符串常量池里的引用
  4. Java虚拟机内部的引用。基本数据类型对应的Class对象，一些常驻的异常对象（NullPointException,OutOfMemoryError），还有系统类加载器。
  5. 所有被同步锁持有的对象
  6. 反映Java虚拟机内部情况的JMXBean,JVMTI中注册额回调，本地代码缓存。

  根节点枚举：以可达性分析算法从GC Roots集合中找引用链。通过OopMap的数据结构找到跨区的引用关系。但是OopMap的记录发生在安全点。所以只有在安全点进行垃圾回收，才认为是有效的。垃圾收集发生时，跑到最近的安全点，然后停顿下来。

  抢先式中断：在垃圾收集发生时，系统首先把所有的用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，知道跑到安全点为止

  主动式中断：当垃圾收集需要中断线程的时候，不直接对线程操作，设置一个标志，一旦发现中断标志位真时，就自己在最近的安全点上主动中断挂起。

  ## 记忆集

  记录从非收集区域指向收集区域指针集合的抽象数据结构

  3种精度：

  1. 字长精度：每个记录精确到一个字节长度，记录跨代指针
  2. 对象精度：每个记录精确到一个对象，该对象的字段含有跨代指针
  3. 卡精度： 每个记录精确到一块内存区域，该区域内有对象含有跨代指针

  ## 三色标记

  白色：表示对象尚未被垃圾收集器访问过，在可达性分析刚刚开始的阶段，所有的对象都是白色的，在分析结束的阶段，仍然是白色的对象，代表不可达

  黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的。如果有其他对象引用指向了黑色对象，无需重新扫描。黑色对象不可能直接指向某个白色对象

  灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

# 垃圾回收算法

- 标记清除（mark-sweep）-位置不连续 产生碎片
- 标记复制(copying)-没有碎片，浪费空间
- 标记整理（mark-compact）没有碎片，
- 标记压缩(mark-compact)-没有碎片，效率偏低

# 内存分代模型

- 新生代+老年代+永久代（1.7）+元数据（1.8）
- 永久代/元数据区  存放class文件
- 永久代必须指定大小限制，元数据区可以设置，也可以不设置
- 字符串常量 1.7存放永久代 1.8 堆

##  新生代

- Eden + 2个suvivor区 8：1：1
- YGC回收之后，大多数的对象会被回收，活着的进入s0
- 再次YGYGC,活着的对象eden + s0 --> s1
- 再次YGC, eden + s1 --> s0
- 年龄足够 --> 老年代 （15  cms 6）
- s区装不下 --> 老年代

## 老年代

- full GC --> FGC

## GC Tuning

- 尽量减少FGC
- MinorGC = YGC
- MajorGC = FGC

# 垃圾回收器

-  Serial   年轻代  单线程  stop the world 串行回收 

-  parNew  年轻代 配合CMS 并行回收

-  Parallel  Scavenge    年轻代 并行回收

-  Epsilon

-  CMS  ConcurrenMarkSweep 老年代 并发的  垃圾回收和应用程序同时运行，降低STW的时间（200ms）

-  Serial Old

-  Parallel Old

-  G1(10ms)

-  ZGC(1ms)

-  Shenandoah

![](.\img\20201101223811.png)



