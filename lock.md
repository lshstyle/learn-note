# 公平锁

多个线程按照申请锁的顺序来获取锁

# 非公平锁

多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程先获取锁。有可能会造成优先级反转或者饥饿现象。

# 可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

# 独享锁

独享锁是指该锁一次只能被一个线程所持有 ReentrantLock 

# 共享锁

共享锁是指该锁可被多个线程所持有 ReadWriteLock读锁

# 互斥锁

互斥锁具体实现就是ReentrantLock

# 读写锁

读写锁具体实现是ReadWriteLock

# 乐观锁

乐观锁认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的

# 悲观锁

悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式，悲观的认为，不加锁的并发操作一定会出问题。

# 分段锁

分段锁其实是一种锁的设计，并不是具体的一种锁。对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

ConcurrentHashMap中的分段锁称为Segment,类似于HashMap的结构，内部拥有一个Entry数据，数据中的每个元素又是一个链表；同时又是一个ReentrantLock。

当需要put元素的时候，并不是对整个hashMap进行加锁，而是先通过hashcode来知道他要放在那个分段中，然后对这个分段进行加锁。所以多线程put的时候，只要不是放在一个分段中，就实现了真正的并行插入。

在统计size的时候，需要获取所有分段锁才能统计。

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数据的时候，就针对数据中的一项进行加锁操作。

# 偏向锁

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

# 轻量级锁

轻量级锁是指党所是偏向锁的时候，被另一个线程所访问，偏向锁就会升级未轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

# 重量级锁

重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会支持持续下去，当自旋一定次数的时候，还诶有获取到锁，就会进入阻塞，改锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

# 自旋锁

自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式尝试获取锁，这样的好处是减少线程上下文的切换消耗，缺点是循环会消耗CPU。