[TOC]

## 影响数据库性能的两大方面：

1. 查询数据扫表范围
2. 减少IO次数

## 索引分类

1.主键索引 主键作为索引的列

2.唯一索引  唯一索引允许出现空值，但是主键索引不允许。

3.普通索引   既不是主键索引也不是唯一索引

4.全文索引  中文分析器  对大文本进行拆分，对词汇查询的时候，很快知道词汇所在位置

5.组合索引  多个列组成的索引

## 数据结构

### 二叉树

名词释义：

1.结点  包含一个数据元素及若干指向子树分支的结点

2.结点的度  一个结点拥有子树的数目

3.叶子结点 没有子树的结点或者度为0的结点

4.分支结点  度不为0的结点

5.树的度 树中所有结点的度的最大值

6.结点的层次  从根节点开始，假设根结点为第L层，那么其子节点位于L+1层

7.树的高度  树中所有结点的层次最大值称为树的深度

### BST Binary Search Tree

二叉搜索树是一种有序的二叉树

左子树必须小于根节点

右子树必须大于根节点

如果递增或者递减顺序，会退化成链表

### AVL  二叉平衡树

保证平衡，在插入时旋转根节点。最短子树和最长子树高度差不能超过1

### 红黑树 Red Black Tree

最短子树和最长子树高度差不能差2倍

### B-Tree

每层结点元素增加，容纳更多的数据

数据和索引存储在一起

### B+Tree

数据只存储在叶子结点，并且维护一个双向链表

## 聚簇索引

有几个索引就有几个B+Tree，但是只有一个聚簇索引。存放数据的索引一般是主键索引，也成为聚簇索引。索引和数据存储在一起。

## 回表

根据非主键索引查找，找到的并非数据，而是主键，所以需要根据主键再查第二次，拿到数据。这个过程称为回表

## 索引覆盖

如果根据非聚簇索引查找，可以直接找到数据列，而不用根据主键二次查找，称为索引覆盖。

## 最左匹配 

name  age建索引，必须先匹配到name,才能匹配到age

where name = ? and age = ?  使用索引

where name = ?  使用索引

where age = ?  不使用索引

where age = ? and name = ?   使用索引

## 索引下推

name和age组合索引

5.6之前先根据name去存储引擎中拿到所以的数据，然后在server层对age进行数据guol过滤。

5.6之后先根据name,age两个列的值去获取数据，直接把数据返回。

## 索引匹配

   1.全值匹配 所有的索引列都匹配上

2. 匹配最左前缀列

# 索引优化

- 选择唯一性作为索引

  唯一索引的值是唯一的，可以更快速的通过改索引来确定某条记录。

- 为经常需要排序、分组和联合操作的字段建立索引

  经常需要ORDER BY、GROUP BY、DISTINCT、UNION等操作的字段，排序操作会浪费很多时间，如果为其建立索引，可以有效地避免排序操作。

- 为常作为查询条件的字段建立索引

  如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。

- 限制索引的数目

  索引的数据不是越多越好，每个索引都要占用磁盘空间，索引越多，需要的磁盘空间越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。

- 尽量使用数据量少的索引

  如果索引的值很长，那么查询的速度会受到影响。

- 尽量使用前缀来索引

  如果索引字段的值很长，最好使用值的前缀来索引。

- 删除不再使用或者很少使用的索引

  表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

- 最左前缀匹配原则

  mysql会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配。

- = 和in 可以乱序

  mysql的查询优化器会帮你优化成索引可以识别的形式，顺序无关性。

- 尽量选择区分度高的列作为索引

  区分度的公式是count(distinct col)/count(*),表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上。

- 索引列不能参与计算，保持列"干净"

- 尽量的扩展索引，不要新建索引

比如表中已经有a的索引，现在加(a,b)的索引，那么只需要修改原来的索引即可。



# 性能优化

## select_type

- SIMPLE

  简单select ,不使用union或者子查询

- PRIMARY

  查询中若包含任何复杂的子部分，最外层的select被标记为primary

- UNION

  union中的第二个或者后面的select语句

- DEPENDENT UNION

  union中的第二个或后面的select语句，取决于外面的查询

- UNION RESULT

  union的结果

- SUBQUERY

  子查询中的第一个select

- DEPENDENT SUBQUERY

  子查询中的第一个select,取决于外面的查询

- DERIVED

  派生表的select,from子句的子查询

- UNCACHEABLE SUBQUERY

  一个子查询的结果不能被缓存，必须重新评估外链接的第一行

## type

type表示Mysql在表中找到所需行的方式，又称"访问类型"，常用的类型有：ALL,index,range,ref,eq_ref,const,system,NULL

- ALL

  Full Table Scan ,Mysql 将遍历全表以找到匹配的行

- index

  Full Index Scan， index与All区别为index类型只遍历索引树

- range

  只检索费定范围的行，使用一个索引来选择行

- ref

  表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。

- eq_ref

  类似ref,区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key 或者unique key 作为关联条件

- const

  当Mysql对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，Mysql就能将该查询转换为一个常量

- NULL

  mysql在优化过程中分解语句，执行时甚至不用访问表或索引。

## key

key列显示Mysql实际决定使用的键，如果没有选择索引，键是NULL

## possible_keys

possible_keys指出mysql能使用哪个索引在表中找到记录，查询涉及到的字段上如果存在索引，则该索引将被列出，但不一定被查询使用。

## ref

ref表示上述表的链接匹配条件，即那些列或常量被用于查找索引列上的值

## rows

rows表示mysql根据表统计信息，一级索引选用的情况，找到所需记录需要读取的行数，这个行数是估算值，实际行数可能不同。











 

 

